{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["import axios from 'axios';\nimport { defineStore } from \"pinia\";\nimport { auth, db } from \"../../firebaseConfig\";\nimport { createUserWithEmailAndPassword, \n\t\tsignInWithEmailAndPassword,\n\t\tonAuthStateChanged,\n\t\tsignOut} from \"firebase/auth\";\nimport { collection, query, where, getDoc, \n\t\tgetDocs, addDoc, deleteDoc, doc,\n\t\tupdateDoc } from 'firebase/firestore'\nimport router from '../router';\nimport { nanoid } from 'nanoid';\nexport const useUserStore = defineStore(\"user\", {\n  state: () => ({\n      userData: \"bluuweb\",\n      userInfo: {},\n      loadingUser: false,\n      loading: true,\n      loadingSession: false\n  }),\n  getters: {\n    minuscula(state) {\n      return state.userData.toLowerCase();\n    },\n    mayusculaInicial(state) {\n      return state.userData.replace(/\\b\\w/g, (match) => match.toUpperCase())\n    },\n    mayuscula(state) {\n      return state.userData.toUpperCase();\n    }\n  }, \n  actions: {\n    registro(name) {\n      this.userData = name;\n    },\n    \n    async registerUser(email, password) {\n      this.loadingUser = true;\n      try {\n        const { user } = await createUserWithEmailAndPassword(\n          auth,\n          email,\n          password\n        );\n        // console.log(user);\n        this.userInfo = { email: user.email, uid: user.uid }\n        this.loading = false;\n        router.push(\"/\");\n      } catch (e) {\n        console.log(e);\n        this.userInfo = {};\n      } finally {\n        this.loadingUser = false;\n      }\n    },\n\n    async loginUser(email, password) {\n      this.loadingUser = true;\n      try {\n        const { user } = await signInWithEmailAndPassword(\n          auth,\n          email,\n          password\n        );\n        // console.log(user);\n        this.userInfo = {\n          email: user.email,\n          uid: user.uid\n        };\n        this.loading = false;\n        router.push(\"/\");\n      } catch(e) {\n        // statements\n        console.log(e);\n        this.userInfo = {};\n      } finally {\n        this.loadingUser = false;\n      }\n    }, \n\n    async signOutUser() {\n      this.loadingUser = true;\n      try {\n        await auth.signOut();\n        this.userInfo = {};\n        this.loading = true;\n        router.push(\"/login\");\n      } catch(e) {\n        // statements\n        console.log(e);\n      } finally {\n        // statements\n        this.loadingUser = false;\n      }\n    },\n\n    currentUser() {\n      return new Promise((resolve, reject) => {\n        const unsubscribe = onAuthStateChanged(auth, (user) => {\n          if (user) {\n            this.userInfo = {\n              email: user.email,\n              uid: user.uid\n            };\n          } else {\n            this.userInfo = {};\n          }\n          resolve(user);\n        }, (error) => {\n          console.error('Error en onAuthStateChanged:', error);\n          reject(error);\n        });\n\n        // Dependiendo de tus necesidades, puedes o no querer desuscribirte inmediatamente.\n        // Si lo haces, solo recibirás el primer cambio y luego dejarás de escuchar.\n        // Si no lo haces, seguirás escuchando cambios hasta que el componente sea destruido o hasta que desactives manualmente el listener.\n        // unsubscribe();\n      });\n    }\n  }\n});\n\nexport const useDatabaseStore = defineStore('database', {\n\tstate: () => ({\n\t\tdocuments: [],\n\t\tloadingDoc: false,\n\t\tuserUid: ''\n\t}),\n\tgetters: {\n\n\t},\n\tactions: {\n\t\tasync getUrls() {\n\t\t\tif (this.documents.length !== 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.loadingDoc = true;\n\t\t\tthis.documents = [];\n\t\t\ttry {\n\t\t\t\t const q = query(collection(db, 'urls'), \n\t\t\t\t \twhere(\"user\", \"==\", auth.currentUser.uid));\n\t\t\t\t const querySnapshot = await getDocs(q)\n\t\t\t\t querySnapshot.forEach((doc) => {\n\t\t\t\t \t// console.log(doc.id, doc.data());\n\t\t\t\t \tthis.documents.push({\n\t\t\t\t \t\tid: doc.id,\n\t\t\t\t \t\t...doc.data()\n\t\t\t\t \t});\n\t\t\t\t });\n\t\t\t\t // console.log(this.documents);\n\t\t\t} catch(e) {\n\t\t\t\t// statements\n\t\t\t\tconsole.log(e);\n\t\t\t} finally {\n\t\t\t\t// statements\n\t\t\t\tthis.loadingDoc = false;\n\t\t\t}\n\t\t},\n\t\tsignOutUser() {\n\t\t\tthis.documents = [];\n\t\t},\n\t\tlectura(texto) {\n\t\t\tconsole.log(\"hola a todos\", texto)\n\t\t},\n\t\tasync addUrl(name) {\n\t\t\tthis.loadingDoc = true;\n\t\t\ttry {\n\t\t\t\tconst objetoDoc = {\n\t\t\t\t\tname: name,\n\t\t\t\t\tshort: nanoid(6),\n\t\t\t\t\tuser: auth.currentUser.uid\n\t\t\t\t};\n\t\t\t\tconst docRef = await addDoc(collection(db, \"urls\"), objetoDoc);\n\t\t\t\t// console.log(docRef);\n\t\t\t\tthis.documents.push({\n\t\t\t\t\t...objetoDoc,\n\t\t\t\t\tid: docRef.id\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\t// statements\n\t\t\t\tconsole.log(e);\n\t\t\t} finally {\n\t\t\t\t// statements<\n\t\t\t\tthis.loadingDoc = false;\n\t\t\t}\n\t\t},\n\t\tasync deleteUrl(id) {\n\t\t\tthis.loadingDoc = true;\n\t\t\ttry {\n\t\t\t\tconst docRef = await doc(db, \"urls\", id);\n\t\t\t\tconst docSnap = await getDoc(docRef);\n\n\t\t\t\tif (!docSnap.exists()) {\n\t\t\t\t\tthrow new Error('no existe el documentos');\n\t\t\t\t}\n\t\t\t\tif(docSnap.data().user !== auth.currentUser.uid) {\n\t\t\t\t\tthrow new Error('no existe el documentos');\n\t\t\t\t}\n\t\t\t\tawait deleteDoc(docRef);\n\t\t\t\tthis.documents = this.documents.filter(item => item.id !== id)\n\t\t\t} catch(e) {\n\t\t\t\t// statements\n\t\t\t\tconsole.log(e);\n\t\t\t} finally {\n\t\t\t\t// statements\n\t\t\t\tthis.loadingDoc = false;\n\t\t\t}\n\t\t},\n\n\t\tasync readUrl() {\n\t\t\tthis.loadingDoc = true;\n\t\t\ttry {\n\t\t\t\tconst docRef = await doc(db, \"urls\", this.userUid);\n\t\t\t\tconst docSnap = await getDoc(docRef);\n\n\t\t\t\tif (!docSnap.exists()) {\n\t\t\t\t\tthrow new Error('no existe el documentos');\n\t\t\t\t}\n\t\t\t\tif(docSnap.data().user !== auth.currentUser.uid) {\n\t\t\t\t\tthrow new Error('no existe el documentos');\n\t\t\t\t}\n\t\t\t\treturn docSnap.data().name;\n\t\t\t} catch(e) {\n\t\t\t\t// statements\n\t\t\t\tconsole.log(e);\n\t\t\t} finally {\n\t\t\t\t// statements\n\t\t\t\tthis.loadingDoc = false;\n\t\t\t}\n\t\t},\n\n\t\tasync updateUrl(name){\n\t\t\t// console.log(name);\n\t\t\tthis.loadingDoc = true;\n\t\t\ttry {\n\t\t\t\tconst docRef = await doc(db, \"urls\", this.userUid);\n\t\t\t\tconst docSnap = await getDoc(docRef);\n\n\t\t\t\tif (!docSnap.exists()) {\n\t\t\t\t\tthrow new Error('no existe el documentos');\n\t\t\t\t}\n\t\t\t\tif(docSnap.data().user !== auth.currentUser.uid) {\n\t\t\t\t\tthrow new Error('no existe el documentos');\n\t\t\t\t}\n\t\t\t\tawait updateDoc(docRef, { name: name });\n\t\t\t\tthis.documents = this.documents.map((item) => \n\t\t\t\t\titem.id === this.userUid ? { ...item, name: this.userUid } : item\n\t\t\t\t);\n\t\t\t\trouter.push(\"/\");\n\t\t\t} catch(e) {\n\t\t\t\t// statements\n\t\t\t\tconsole.log(e);\n\t\t\t} finally {\n\t\t\t\t// statements\n\t\t\t\tthis.loadingDoc = false;\n\t\t\t}\n\t\t}\n\t}\n})"],"file":"bundle.js"}